#!/usr/bin/env bash
# mediactl - Unified media player controller
# Manages browser-based media (YouTube, Spotify Web) and dedicated players (Spotify, MPD, SubsonicTUI)
# with intelligent priority-based source selection

set -euo pipefail

# ============================================================================
# CONFIGURATION
# ============================================================================

readonly SCRIPT_NAME="mediactl"
readonly VERSION="1.2.0"  # updated version

readonly BROWSER_PLAYERS=(
    "firefox"
    "chromium"
    "chrome"
    "brave"
    "plasma-browser-integration"
)

readonly SONG_PLAYERS=(
    "spotify"
    "SubsonicTUI"
    "mpd"
    "mopidy"
    "elisa"
    "rhythmbox"
)

readonly CACHE_DIR="${XDG_RUNTIME_DIR:-/tmp}/mediactl"
readonly PLAYER_LIST_CACHE="$CACHE_DIR/players"
readonly CACHE_LIFETIME=1  # seconds

readonly ICON_BROWSER="ðŸŒ"
readonly ICON_SONG="ðŸŽµ"
readonly ICON_PLAYING="ï‹ "
readonly ICON_PAUSED="ïŒ "
readonly ICON_STOPPED="ï "
readonly ICON_IDLE="ï "

SOURCE=""  # global source filter

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

function die() {
    echo "$SCRIPT_NAME: $*" >&2
    exit 1
}

function check_dependencies() {
    if ! command -v playerctl &>/dev/null; then
        die "playerctl not found. Install it to use $SCRIPT_NAME"
    fi
}

function init_cache_dir() {
    mkdir -p "$CACHE_DIR"
}

function is_cache_fresh() {
    local cache_file="$1"
    [[ -f "$cache_file" ]] || return 1

    local now mod_time age
    now=$(date +%s)
    mod_time=$(stat -c %Y "$cache_file" 2>/dev/null || echo 0)
    age=$((now - mod_time))

    [[ $age -lt $CACHE_LIFETIME ]]
}

# ============================================================================
# PLAYER DETECTION & CLASSIFICATION
# ============================================================================

function get_all_players() {
    if is_cache_fresh "$PLAYER_LIST_CACHE"; then
        cat "$PLAYER_LIST_CACHE"
        return 0
    fi

    local players
    players=$(playerctl -l 2>/dev/null || echo "")
    echo "$players" | tee "$PLAYER_LIST_CACHE"
}

function is_browser_player() {
    local player="$1"
    for bp in "${BROWSER_PLAYERS[@]}"; do
        [[ "$player" == *"$bp"* ]] && return 0
    done
    return 1
}

function is_song_player() {
    local player="$1"
    for sp in "${SONG_PLAYERS[@]}"; do
        [[ "$player" == *"$sp"* ]] && return 0
    done
    return 1
}

function get_browser_players() {
    local all_players
    all_players=$(get_all_players)

    while IFS= read -r player; do
        [[ -z "$player" ]] && continue
        if is_browser_player "$player"; then
            local status
            status=$(playerctl -p "$player" status 2>/dev/null || echo "Stopped")
            echo "$player|$status"
        fi
    done <<< "$all_players"
}

function get_song_players() {
    local all_players
    all_players=$(get_all_players)

    while IFS= read -r player; do
        [[ -z "$player" ]] && continue
        if is_song_player "$player"; then
            local status
            status=$(playerctl -p "$player" status 2>/dev/null || echo "Stopped")
            echo "$player|$status"
        fi
    done <<< "$all_players"
}

# ============================================================================
# PRIORITY RESOLUTION
# ============================================================================

function get_active_player() {
    local filter="${1:-}"

    local active_info

    if [[ "$filter" == "browser" ]]; then
        active_info=$(get_browser_players | awk -F'|' '$2=="Playing" || $2=="Paused"{print "browser|"$1"|"$2; exit}')
        [[ -z "$active_info" ]] && active_info="idle||Idle"
        echo "$active_info"
        return
    fi

    if [[ "$filter" == "song" ]]; then
        active_info=$(get_song_players | awk -F'|' '$2=="Playing" || $2=="Paused"{print "song|"$1"|"$2; exit}')
        [[ -z "$active_info" ]] && active_info="idle||Idle"
        echo "$active_info"
        return
    fi

    # Default: browser > song
    active_info=$(get_browser_players | awk -F'|' '$2=="Playing"{print "browser|"$1"|"$2; exit}')
    [[ -z "$active_info" ]] && active_info=$(get_song_players | awk -F'|' '$2=="Playing"{print "song|"$1"|"$2; exit}')
    [[ -z "$active_info" ]] && active_info="idle||Idle"
    echo "$active_info"
}

# ============================================================================
# METADATA RETRIEVAL
# ============================================================================

function get_player_metadata() {
    local player="$1"

    [[ "$player" == "idle" ]] && {
        echo "Idle||||"
        return 0
    }

    local status title artist album art_url
    status=$(playerctl -p "$player" status 2>/dev/null || echo "Stopped")
    title=$(playerctl -p "$player" metadata title 2>/dev/null || echo "Unknown")
    artist=$(playerctl -p "$player" metadata artist 2>/dev/null || echo "Unknown")
    album=$(playerctl -p "$player" metadata album 2>/dev/null || echo "")
    art_url=$(playerctl -p "$player" metadata mpris:artUrl 2>/dev/null || echo "")

    echo "$status|$title|$artist|$album|$art_url"
}

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

function get_state() {
    local filter="${1:-}"
    local active_info type player status metadata
    active_info=$(get_active_player "$filter")
    IFS='|' read -r type player status <<< "$active_info"

    if [[ "$type" == "idle" ]]; then
        echo "idle||Idle|||"
        return
    fi

    metadata=$(get_player_metadata "$player")
    echo "$type|$player|$metadata"
}

function get_status_icon() {
    local status="$1"
    case "$status" in
        Playing) echo "$ICON_PLAYING" ;;
        Paused)  echo "$ICON_PAUSED" ;;
        Stopped) echo "$ICON_STOPPED" ;;
        Idle)    echo "$ICON_IDLE" ;;
        *)       echo "" ;;
    esac
}

function get_source_icon() {
    local type="$1"
    case "$type" in
        browser) echo "$ICON_BROWSER" ;;
        song)    echo "$ICON_SONG" ;;
        *)       echo "" ;;
    esac
}

function format_title() {
    local title="$1"
    local cutpoint="${2:-50}"

    [[ "$title" == "Unknown" || "$title" == "Idle" ]] && {
        echo "$title"
        return
    }

    if [[ ${#title} -gt $cutpoint ]]; then
        echo "${title:0:$cutpoint}â€¦"
    else
        echo "$title"
    fi
}

# ============================================================================
# CONTROL COMMANDS
# ============================================================================

function send_control() {
    local command="$1"
    local active_info type player status
    active_info=$(get_active_player "$SOURCE")
    IFS='|' read -r type player status <<< "$active_info"

    [[ "$player" == "idle" ]] && {
        echo "No active player for source '$SOURCE'" >&2
        return 1
    }

    playerctl -p "$player" "$command" 2>/dev/null || {
        echo "Failed to send $command to $player" >&2
        return 1
    }
}

# ============================================================================
# COMMAND HANDLERS
# ============================================================================

function cmd_status() { get_state "$SOURCE"; }
function cmd_title() {
    local cutpoint="${1:-50}"
    local state title
    state=$(get_state "$SOURCE")
    IFS='|' read -r _ _ _ title _ _ _ <<< "$state"
    format_title "$title" "$cutpoint"
}
function cmd_state() {
    local state type status
    state=$(get_state "$SOURCE")
    IFS='|' read -r type _ status _ _ _ _ <<< "$state"
    [[ "$type" == "idle" ]] || [[ "$status" != "Playing" ]] && { echo "$ICON_IDLE"; return; }
    get_status_icon "$status"
}
function cmd_state_title() {
    local cutpoint="${1:-50}"
    local state type status title icon
    state=$(get_state "$SOURCE")
    IFS='|' read -r type _ status title _ _ _ <<< "$state"
    [[ "$type" == "idle" ]] || [[ "$status" != "Playing" ]] && { echo "$ICON_IDLE Idle"; return; }
    icon=$(get_status_icon "$status")
    title=$(format_title "$title" "$cutpoint")
    echo "$icon $title"
}
function cmd_get_active_player() {
    local active_info type
    active_info=$(get_active_player "$SOURCE")
    IFS='|' read -r type _ _ <<< "$active_info"
    echo "$type"
}
function cmd_play_pause() { send_control play-pause; }
function cmd_next()       { send_control next; }
function cmd_previous()   { send_control previous; }

# ============================================================================
# HELP & VERSION
# ============================================================================

function show_help() {
    cat << EOF
$SCRIPT_NAME v$VERSION - Unified media player controller

USAGE:
    $SCRIPT_NAME [--source <browser|song>] <command> [options]

COMMANDS:
    status              Get full state (type|player|status|title|artist|album|art_url)
    title [cutpoint]    Get formatted title (default cutpoint: 50)
    state               Get status icon only
    state-title [cut]   Get icon + title
    get-active-player   Get active source type (browser|song|idle)
    play-pause          Toggle playback
    next                Next track
    previous            Previous track
    help                Show this help message
    version             Show version

SOURCE FILTER:
    --source <browser|song>  Restrict commands to a specific category

EXAMPLES:
    $SCRIPT_NAME --source browser play-pause
    $SCRIPT_NAME -s song next
    $SCRIPT_NAME state-title 30

EOF
}

function show_version() { echo "$SCRIPT_NAME v$VERSION"; }

# ============================================================================
# MAIN
# ============================================================================

function main() {
    check_dependencies
    init_cache_dir

    # Parse optional source flag
    if [[ $# -ge 2 ]] && [[ "$1" == "--source" || "$1" == "-s" ]]; then
        SOURCE="$2"
        shift 2
        [[ "$SOURCE" != "browser" && "$SOURCE" != "song" ]] && die "Invalid source: $SOURCE"
    fi

    local command="${1:-help}"
    shift || true

    case "$command" in
        status)           cmd_status ;;
        title)            cmd_title "$@" ;;
        state)            cmd_state ;;
        state-title)      cmd_state_title "$@" ;;
        get-active-player) cmd_get_active_player ;;
        play-pause)       cmd_play_pause ;;
        next)             cmd_next ;;
        previous)         cmd_previous ;;
        help|--help|-h)   show_help ;;
        version|--version|-v) show_version ;;
        *)                die "Unknown command: $command (try '$SCRIPT_NAME help')" ;;
    esac
}

main "$@"

