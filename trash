#!/usr/bin/env bash
# ======================================
# Improved Standalone Trash Utility
# ======================================

set -euo pipefail

TRASH_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/Trash"
FILES_DIR="$TRASH_DIR/files"
INFO_DIR="$TRASH_DIR/info"
FZF=$(command -v fzf 2>/dev/null || true)
mkdir -p "$FILES_DIR" "$INFO_DIR"

function usage() {
    cat <<'EOF'
Usage:
  trash put <file...>         Move files to trash
  trash list                  List trashed files
  trash restore               Interactively restore trashed files
  trash empty [days]          Empty trash (optionally older than N days)
  trash size                  Show total trash size
  trash help                  Show this help

Examples:
  trash put old.txt dir/
  trash list
  trash restore
  trash empty 30
EOF
    exit 1
}

function timestamp() { date +"%Y-%m-%dT%H:%M:%S"; }

# --- Move files to trash ---
function put_trash() {
    [[ $# -lt 1 ]] && echo "Error: specify files to trash" && exit 1

    for f in "$@"; do
        if [[ ! -e "$f" ]]; then
            echo "‚ö†Ô∏è  Skipping: $f (not found)" >&2
            continue
        fi

        # Resolve to absolute path BEFORE moving
        orig_path=$(realpath "$f")
        base=$(basename "$f")

        # Interactive confirmation
        printf "trash: move '%s' to trash? [y/N]: " "$f"
        read -r ans </dev/tty
        [[ "$ans" =~ ^[Yy]$ ]] || { echo "Skipped."; continue; }

        # Generate unique trash filename
        dest="$FILES_DIR/$base"
        if [[ -e "$dest" ]]; then
            timestamp_suffix=$(date +%s)
            dest="$FILES_DIR/${base}_${timestamp_suffix}"
        fi

        # Move file (handle cross-filesystem moves)
        if ! mv "$f" "$dest" 2>/dev/null; then
            # Fallback: copy then remove (for cross-filesystem)
            cp -a "$f" "$dest" && rm -rf "$f"
        fi

        # Create trashinfo metadata
        trash_name=$(basename "$dest")
        cat > "$INFO_DIR/${trash_name}.trashinfo" <<EOF
[Trash Info]
Path=$orig_path
DeletionDate=$(timestamp)
EOF

        echo "‚úì Moved to trash: $f"
    done
}

# --- List trashed files ---
function list_trash() {
    if ! compgen -G "$INFO_DIR/*.trashinfo" >/dev/null; then
        echo "(trash is empty)"
        return
    fi

    printf "%-20s  %-8s  %-50s\n" "DELETED" "SIZE" "ORIGINAL PATH"
    echo "--------------------------------------------------------------------------------"

    for info in "$INFO_DIR"/*.trashinfo; do
        [[ -f "$info" ]] || continue

        trash_name=$(basename "$info" .trashinfo)
        orig_path=$(grep '^Path=' "$info" 2>/dev/null | cut -d= -f2- || echo "unknown")
        date=$(grep '^DeletionDate=' "$info" 2>/dev/null | cut -d= -f2- || echo "unknown")

        if [[ -e "$FILES_DIR/$trash_name" ]]; then
            size=$(du -sh "$FILES_DIR/$trash_name" 2>/dev/null | awk '{print $1}')
        else
            size="missing"
        fi

        printf "%-20s  %-8s  %s\n" "$date" "$size" "$orig_path"
    done | sort -r
}

# --- Restore trashed files ---
function restore_trash() {
    if [[ -z "$FZF" ]]; then
        echo "Error: fzf not found. Install fzf for interactive restore." >&2
        exit 1
    fi

    if ! compgen -G "$INFO_DIR/*.trashinfo" >/dev/null; then
        echo "(trash is empty)"
        return
    fi

    # Build selection list with trash_name|original_path
    temp_list=$(mktemp)
    for info in "$INFO_DIR"/*.trashinfo; do
        trash_name=$(basename "$info" .trashinfo)
        orig_path=$(grep '^Path=' "$info" 2>/dev/null | cut -d= -f2-)
        date=$(grep '^DeletionDate=' "$info" 2>/dev/null | cut -d= -f2-)
        echo "$trash_name|$orig_path|$date"
    done > "$temp_list"

    # Let user select with fzf
    selections=$(cat "$temp_list" | \
            awk -F'|' '{printf "%-20s  %s\n", $3, $2}' | \
        fzf -m --ansi --prompt="Select files to restore> " || true)

    [[ -z "$selections" ]] && { rm "$temp_list"; echo "No files selected."; exit 0; }

    # Parse selections and restore
    echo "$selections" | while read -r line; do
        # Extract original path from selection
        orig_path=$(echo "$line" | awk '{$1=""; print $0}' | sed 's/^ *//')

        # Find matching trash_name
        trash_name=$(grep -F "|$orig_path|" "$temp_list" | cut -d'|' -f1)

        info="$INFO_DIR/${trash_name}.trashinfo"
        file="$FILES_DIR/$trash_name"

        if [[ ! -f "$info" || ! -e "$file" ]]; then
            echo "‚ö†Ô∏è  Skipping: $orig_path (metadata missing)" >&2
            continue
        fi

        # Check if destination exists
        if [[ -e "$orig_path" ]]; then
            printf "‚ö†Ô∏è  '%s' already exists. Overwrite? [y/N]: " "$orig_path"
            read -r ans </dev/tty
            [[ "$ans" =~ ^[Yy]$ ]] || { echo "Skipped."; continue; }
            rm -rf "$orig_path"
        fi

        # Restore file
        mkdir -p "$(dirname "$orig_path")"
        mv "$file" "$orig_path" && rm "$info"
        echo "‚úì Restored: $orig_path"
    done

    rm "$temp_list"
}

# --- Empty trash ---
function empty_trash() {
    local days="${1:-0}"

    if ! compgen -G "$INFO_DIR/*.trashinfo" >/dev/null; then
        echo "(trash is already empty)"
        return
    fi

    if [[ "$days" -gt 0 ]]; then
        echo "üóëÔ∏è  Removing items older than $days days..."
        count=0
        find "$INFO_DIR" -type f -name "*.trashinfo" -mtime +"$days" | while read -r info; do
            trash_name=$(basename "$info" .trashinfo)
            rm -rf "$FILES_DIR/$trash_name" "$info"
            ((count++)) || true
        done
        echo "‚úì Removed $count old item(s)"
    else
        printf "‚ö†Ô∏è  Permanently delete all trashed files? [y/N]: "
        read -r ans </dev/tty
        [[ "$ans" =~ ^[Yy]$ ]] || { echo "Aborted."; exit 0; }
        rm -rf "$FILES_DIR"/* "$INFO_DIR"/*
        echo "‚úì Trash emptied."
    fi
}

# --- Show total trash size ---
function trash_size() {
    if [[ -d "$FILES_DIR" ]]; then
        echo "üìä Trash size:"
        du -sh "$FILES_DIR" 2>/dev/null || echo "0B"
    else
        echo "(trash is empty)"
    fi
}

# --- Main ---
cmd="${1:-help}"
shift || true

case "$cmd" in
    put|rm) put_trash "$@" ;;
    list|ls) list_trash ;;
    restore) restore_trash ;;
    empty|clean) empty_trash "${1:-}" ;;
    size|du) trash_size ;;
    help|--help|-h) usage ;;
    *)
        echo "Unknown command: $cmd" >&2
        usage
        ;;
esac
