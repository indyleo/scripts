#!/usr/bin/env bash
# medianotify - Event-driven media player notification daemon
# Monitors media state changes via playerctl events and queries mediactl

set -euo pipefail

# ============================================================================
# CONFIGURATION
# ============================================================================

readonly SCRIPT_NAME="medianotify"
readonly STATE_DIR="${XDG_RUNTIME_DIR:-/tmp}/medianotify"
readonly STATE_FILE="$STATE_DIR/last_state"
readonly NOTIFICATION_TIMEOUT=5000
readonly NOTIFICATION_APP="Media Player"

# Debounce settings (prevent notification spam from rapid events)
readonly DEBOUNCE_TIME=0.3  # seconds
declare -g LAST_EVENT_TIME=0

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

function log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" >&2
}

function die() {
    log "ERROR: $*"
    exit 1
}

function check_dependencies() {
    command -v mediactl &>/dev/null || die "mediactl not found in PATH"
    command -v playerctl &>/dev/null || die "playerctl not found in PATH"
    command -v notify-send &>/dev/null || die "notify-send not found"
    command -v restatus &>/dev/null || die "restatus not found in PATH"
}

function init_state_dir() {
    mkdir -p "$STATE_DIR"
}

function get_current_time() {
    date +%s.%N
}

function should_debounce() {
    local current_time now_time
    current_time=$(get_current_time)
    now_time=$(echo "$current_time" | cut -d. -f1)

    local elapsed
    elapsed=$(echo "$current_time - $LAST_EVENT_TIME" | bc 2>/dev/null || echo "999")

    if (( $(echo "$elapsed < $DEBOUNCE_TIME" | bc -l 2>/dev/null || echo 0) )); then
        return 0  # Should debounce
    fi

    LAST_EVENT_TIME=$current_time
    return 1  # Don't debounce
}

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

function load_state() {
    if [[ -f "$STATE_FILE" ]]; then
        cat "$STATE_FILE"
    else
        echo "||||"
    fi
}

function save_state() {
    local state="$1"
    echo "$state" > "$STATE_FILE"
}

function should_notify() {
    local old_state="$1"
    local new_state="$2"

    local old_status old_title old_artist
    local new_type new_status new_title new_artist

    IFS='|' read -r _ _ old_status old_title old_artist _ <<< "$old_state"
    IFS='|' read -r new_type _ new_status new_title new_artist _ <<< "$new_state"

    # ONLY notify when something is Playing
    [[ "$new_status" != "Playing" ]] && return 1

    # Don't notify if already notified about this exact playing track
    if [[ "$old_status" == "Playing" && "$old_title" == "$new_title" && "$old_artist" == "$new_artist" ]]; then
        return 1
    fi

    return 0
}

# ============================================================================
# NOTIFICATION FORMATTING
# ============================================================================

function get_notification_title() {
    local new_type="$1"

    local source_icon
    case "$new_type" in
        browser) source_icon="ðŸŒ" ;;
        song)    source_icon="ðŸŽµ" ;;
        *)       source_icon="" ;;
    esac

    echo "$source_icon Now Playing"
}

function get_notification_body() {
    local title="$1"
    local artist="$2"
    local album="$3"

    local body="$title"

    [[ -n "$artist" && "$artist" != "Unknown" ]] && \
        body="$body"$'\n'"by $artist"

    [[ -n "$album" && "$album" != "Unknown" ]] && \
        body="$body"$'\n'"from $album"

    echo "$body"
}

function send_notification() {
    local old_state="$1"
    local new_state="$2"
    local art_url="$3"

    local new_type new_status new_title new_artist new_album
    IFS='|' read -r new_type _ new_status new_title new_artist new_album <<< "$new_state"

    local notif_title notif_body
    notif_title=$(get_notification_title "$new_type")
    notif_body=$(get_notification_body "$new_title" "$new_artist" "$new_album")

    local notify_cmd=(
        notify-send
        -t "$NOTIFICATION_TIMEOUT"
        -a "$NOTIFICATION_APP"
        -u normal
    )

    # Add album art if available
    if [[ -n "$art_url" ]]; then
        local art_path="${art_url#file://}"
        [[ -f "$art_path" ]] && notify_cmd+=(-i "$art_path")
    fi

    notify_cmd+=("$notif_title" "$notif_body")

    "${notify_cmd[@]}" 2>/dev/null || {
        log "Failed to send notification"
        return 1
    }

    log "Notification sent: $notif_title - $new_title"
}

# ============================================================================
# EVENT HANDLING
# ============================================================================

function handle_event() {
    # Debounce rapid successive events
    if should_debounce; then
        return
    fi

    # Get current state from mediactl (uses its intelligent prioritization)
    local current_state
    current_state=$(mediactl status 2>/dev/null || echo "idle||Idle|||")

    # Extract relevant fields
    local type player status title artist album art_url
    IFS='|' read -r type player status title artist album art_url <<< "$current_state"

    # Create state key for comparison (without art_url)
    local state_key="$type|$player|$status|$title|$artist|$album"

    local last_state
    last_state=$(load_state)

    # Check if notification is needed
    if should_notify "$last_state" "$state_key"; then
        send_notification "$last_state" "$state_key" "$art_url"
    fi

    # Trigger restatus update if state changed
    if [[ "$state_key" != "$last_state" ]]; then
        restatus rt 22 2>/dev/null || true
    fi

    # Update state
    save_state "$state_key"
}

# ============================================================================
# EVENT MONITORING
# ============================================================================

function monitor_events() {
    log "Starting event-driven media monitoring"

    # Handle initial state
    LAST_EVENT_TIME=0
    handle_event

    # Keep track of known players
    local known_players=""

    # Main monitoring loop
    while true; do
        # Get current list of players
        local current_players
        current_players=$(playerctl -l 2>/dev/null || echo "")

        # If players changed, restart monitoring
        if [[ "$current_players" != "$known_players" ]]; then
            log "Player list changed, updating monitor..."
            known_players="$current_players"

            # Kill any existing playerctl monitors
            pkill -P $ playerctl 2>/dev/null || true
            sleep 0.1

            # If we have players, start monitoring them
            if [[ -n "$current_players" ]]; then
                log "Monitoring players: $(echo "$current_players" | tr '\n' ' ')"

                # Start monitoring in background
                playerctl -a -F metadata 2>/dev/null | while read -r line; do
                    handle_event
                done &

                playerctl -a -F status 2>/dev/null | while read -r line; do
                    handle_event
                done &
            else
                log "No players available, waiting..."
            fi
        fi

        # Check for player changes every 2 seconds
        sleep 2
    done
}

# Alternative: Monitor specific event types
function monitor_events_v2() {
    log "Starting event-driven media monitoring (v2)"

    LAST_EVENT_TIME=0
    handle_event

    # Create a FIFO for event aggregation
    local event_pipe="$STATE_DIR/events"
    mkfifo "$event_pipe" 2>/dev/null || true

    # Monitor different event types in parallel
    (
        playerctl --all-players -F status 2>/dev/null | while read -r; do echo "event" >> "$event_pipe"; done &
        playerctl --all-players -F metadata 2>/dev/null | while read -r; do echo "event" >> "$event_pipe"; done &
        wait
    ) &

    # Process events from the pipe
    while read -r event; do
        handle_event
    done < "$event_pipe"
}

# ============================================================================
# SIGNAL HANDLING
# ============================================================================

function cleanup() {
    log "Shutting down gracefully"

    # Kill background playerctl processes
    pkill -P $$ playerctl 2>/dev/null || true

    # Clean up FIFO if it exists
    rm -f "$STATE_DIR/events" 2>/dev/null || true

    exit 0
}

trap cleanup SIGINT SIGTERM

# ============================================================================
# HELP & VERSION
# ============================================================================

function show_help() {
    cat << EOF
$SCRIPT_NAME - Event-driven media player notification daemon

USAGE:
    $SCRIPT_NAME [options]

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version

DESCRIPTION:
    Monitors media player state via playerctl EVENTS (no polling!)
    and queries mediactl for intelligent source prioritization.
    Sends desktop notifications when tracks change or playback starts.

FEATURES:
    - Event-driven (instant response, zero polling delay)
    - No CPU usage when idle (only wakes on actual media events)
    - Deduplicates notifications (no spam)
    - Uses mediactl's intelligent browser/song prioritization
    - Shows source indicator (browser ðŸŒ vs song ðŸŽµ)
    - Album art support
    - Smart debouncing for rapid events
    - Persistent state across restarts

NOTIFICATION TRIGGERS:
    âœ“ Track starts playing (new track)
    âœ“ Resume from paused/stopped to playing
    âœ“ Source changes while playing (browser â†” song)
    âœ— No notification when pausing
    âœ— No notification when stopping
    âœ— No notification when idle

HOW IT WORKS:
    1. Listens to playerctl events from ALL players (--all-players)
    2. On any event, queries mediactl for current prioritized state
    3. Debounces rapid successive events (${DEBOUNCE_TIME}s window)
    4. Sends notification only when appropriate

RUNNING AS A SERVICE:
    systemd user service:
        1. Create ~/.config/systemd/user/medianotify.service:

           [Unit]
           Description=Media notification daemon
           After=graphical-session.target

           [Service]
           Type=simple
           ExecStart=/path/to/medianotify
           Restart=on-failure

           [Install]
           WantedBy=default.target

        2. systemctl --user enable --now medianotify.service

REQUIREMENTS:
    - mediactl (your custom media controller)
    - playerctl (for event monitoring)
    - notify-send (for notifications)
    - restatus (for status bar updates)

EOF
}

function show_version() {
    echo "$SCRIPT_NAME v2.0.0 (event-driven)"
}

# ============================================================================
# MAIN
# ============================================================================

function main() {
    case "${1:-}" in
        -h|--help)    show_help; exit 0 ;;
        -v|--version) show_version; exit 0 ;;
        "")           ;;
        *)            die "Unknown option: $1 (try --help)" ;;
    esac

    check_dependencies
    init_state_dir
    monitor_events
}

main "$@"
