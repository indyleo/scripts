#!/usr/bin/env bash
# medianotify - Media player notification daemon
# Monitors media state changes via mediactl and sends desktop notifications
# Features: deduplication, source indication, smart state transitions

set -euo pipefail

# ============================================================================
# CONFIGURATION
# ============================================================================

readonly SCRIPT_NAME="medianotify"
readonly POLL_INTERVAL=1  # seconds between checks

# State file for persistence across restarts
readonly STATE_DIR="${XDG_RUNTIME_DIR:-/tmp}/medianotify"
readonly STATE_FILE="$STATE_DIR/last_state"

# Notification settings
readonly NOTIFICATION_TIMEOUT=5000  # milliseconds
readonly NOTIFICATION_APP="Media Player"

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

function log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" >&2
}

function die() {
    log "ERROR: $*"
    exit 1
}

function check_dependencies() {
    command -v mediactl &>/dev/null || die "mediactl not found in PATH"
    command -v notify-send &>/dev/null || die "notify-send not found"
    command -v restatus &>/dev/null || die "restatus not found in PATH"
}

function init_state_dir() {
    mkdir -p "$STATE_DIR"
}

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

# Load previous state from disk
# Format: type|player|status|title|artist|album
function load_state() {
    if [[ -f "$STATE_FILE" ]]; then
        cat "$STATE_FILE"
    else
        echo "||||"
    fi
}

# Save current state to disk
function save_state() {
    local state="$1"
    echo "$state" > "$STATE_FILE"
}

# Compare two states and determine if notification is needed
# Returns: 0 if notification needed, 1 if no notification
function should_notify() {
    local old_state="$1"
    local new_state="$2"

    local old_status old_title old_artist
    local new_type new_status new_title new_artist

    # Only extract what we actually use; ignore unused fields with _
    IFS='|' read -r _ _ old_status old_title old_artist _ <<< "$old_state"
    IFS='|' read -r new_type _ new_status new_title new_artist _ <<< "$new_state"

    # ONLY notify when something is Playing
    [[ "$new_status" != "Playing" ]] && return 1

    # Don't notify if already notified about this exact playing track
    if [[ "$old_status" == "Playing" && "$old_title" == "$new_title" && "$old_artist" == "$new_artist" ]]; then
        return 1
    fi

    # Notify on:
    # - Track change while playing
    # - Resume from paused/stopped to playing
    # - Source type change
    return 0
}

# ============================================================================
# NOTIFICATION FORMATTING
# ============================================================================

# Get notification title based on state transition
function get_notification_title() {
    local old_status="$1"
    local new_status="$2"
    local new_type="$3"

    local source_icon
    case "$new_type" in
        browser) source_icon="ðŸŒ" ;;
        song)    source_icon="ðŸŽµ" ;;
        *)       source_icon="" ;;
    esac

    # Always "Now Playing" since we only notify on Playing status
    echo "$source_icon Now Playing"
}

# Format notification body
function get_notification_body() {
    local title="$1"
    local artist="$2"
    local album="$3"

    local body="$title"

    [[ -n "$artist" && "$artist" != "Unknown" ]] && \
        body="$body"$'\n'"by $artist"

    [[ -n "$album" && "$album" != "Unknown" ]] && \
        body="$body"$'\n'"from $album"

    echo "$body"
}

# ============================================================================
# NOTIFICATION SENDING
# ============================================================================

function send_notification() {
    local old_state="$1"
    local new_state="$2"
    local art_url="$3"

    local old_status new_type new_status new_title new_artist new_album
    IFS='|' read -r old_status _ _ _ _ _ <<< "$old_state"
    IFS='|' read -r new_type _ new_status new_title new_artist new_album <<< "$new_state"

    local notif_title notif_body
    notif_title=$(get_notification_title "$old_status" "$new_status" "$new_type")
    notif_body=$(get_notification_body "$new_title" "$new_artist" "$new_album")

    # Build notify-send command
    local notify_cmd=(
        notify-send
        -t "$NOTIFICATION_TIMEOUT"
        -a "$NOTIFICATION_APP"
        -u normal
    )

    # Add album art if available
    if [[ -n "$art_url" ]]; then
        # Clean up art URL (remove file:// prefix if present)
        local art_path="${art_url#file://}"
        [[ -f "$art_path" ]] && notify_cmd+=(-i "$art_path")
    fi

    notify_cmd+=("$notif_title" "$notif_body")

    # Send notification
    "${notify_cmd[@]}" 2>/dev/null || {
        log "Failed to send notification"
        return 1
    }

    log "Notification sent: $notif_title - $new_title"
}

# ============================================================================
# MAIN LOOP
# ============================================================================

function monitor_loop() {
	log "Starting media monitoring (poll interval: ${POLL_INTERVAL}s)"

	local last_state
	last_state=$(load_state)

	while true; do
		# Get current state from mediactl
		local current_state
		current_state=$(mediactl status 2>/dev/null || echo "idle||Idle|||")

		# Extract relevant fields for comparison and notification
		local type player status title artist album art_url
		IFS='|' read -r type player status title artist album art_url <<< "$current_state"

		# Create state key for comparison (without art_url)
		local state_key="$type|$player|$status|$title|$artist|$album"

		# Check if notification is needed
		if should_notify "$last_state" "$state_key"; then
			# Pass the full state including art_url for notification
			send_notification "$last_state" "$state_key" "$art_url"
		fi
		if [[ "$state_key" != "$last_state" ]]; then
			restatus rt 22
		fi

		# Update state (save without art_url to avoid comparison issues)
		last_state="$state_key"
		save_state "$state_key"

		# Wait for next poll
		sleep "$POLL_INTERVAL"
	done
}

# ============================================================================
# SIGNAL HANDLING
# ============================================================================

function cleanup() {
    log "Shutting down gracefully"
    exit 0
}

trap cleanup SIGINT SIGTERM

# ============================================================================
# HELP & VERSION
# ============================================================================

function show_help() {
    cat << EOF
$SCRIPT_NAME - Media player notification daemon

USAGE:
    $SCRIPT_NAME [options]

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version

DESCRIPTION:
    Monitors media player state via mediactl and sends desktop notifications
    when tracks change or playback status changes.

FEATURES:
    - Deduplicates notifications (no spam)
    - Shows source indicator (browser ðŸŒ vs song ðŸŽµ)
    - Smart state transitions (Playing â†” Paused â†” Stopped)
    - Album art support
    - Persistent state across restarts

NOTIFICATION TRIGGERS:
    âœ“ Track starts playing (new track)
    âœ“ Resume from paused/stopped to playing
    âœ“ Source changes while playing
    âœ— No notification when pausing
    âœ— No notification when stopping
    âœ— No notification when idle

RUNNING AS A SERVICE:
    systemd user service:
        1. Create ~/.config/systemd/user/medianotify.service
        2. systemctl --user enable --now medianotify.service

EOF
}

function show_version() {
    echo "$SCRIPT_NAME v1.0.0"
}

# ============================================================================
# MAIN
# ============================================================================

function main() {
    case "${1:-}" in
        -h|--help)    show_help; exit 0 ;;
        -v|--version) show_version; exit 0 ;;
        "")           ;;  # No args, proceed to monitor
        *)            die "Unknown option: $1 (try --help)" ;;
    esac

    check_dependencies
    init_state_dir
    monitor_loop
}

main "$@"

