#!/usr/bin/env bash
# medianotify - Event-driven media player notification daemon
# Monitors media state changes via playerctl events and queries mediactl

set -euo pipefail

# ============================================================================
# CONFIGURATION
# ============================================================================

readonly SCRIPT_NAME="medianotify"
readonly STATE_DIR="${XDG_RUNTIME_DIR:-/tmp}/medianotify"
readonly STATE_FILE="$STATE_DIR/last_state"
readonly EVENT_PIPE="$STATE_DIR/event_pipe"
readonly NOTIFICATION_TIMEOUT=5000
readonly NOTIFICATION_APP="Media Player"

# Debounce settings (milliseconds)
readonly DEBOUNCE_TIME_MS=300
declare -g LAST_EVENT_TIME_MS=0

# Track notification history (store timestamps in seconds)
declare -gA NOTIFIED_TRACKS=()

# Job tracking
declare -ga MONITOR_PIDS=()

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

function log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" >&2
}

function die() {
    log "ERROR: $*"
    exit 1
}

function check_dependencies() {
    command -v mediactl &>/dev/null || die "mediactl not found in PATH"
    command -v playerctl &>/dev/null || die "playerctl not found in PATH"
    command -v notify-send &>/dev/null || die "notify-send not found"
    # bc is no longer required
}

function init_state_dir() {
    mkdir -p "$STATE_DIR"
    if [[ ! -p "$EVENT_PIPE" ]]; then
        rm -f "$EVENT_PIPE"
        mkfifo "$EVENT_PIPE"
    fi
}

function get_current_time_ms() {
    # Returns current time in milliseconds
    date +%s%3N
}

function should_debounce() {
    local current_time_ms
    current_time_ms=$(get_current_time_ms)

    local elapsed=$((current_time_ms - LAST_EVENT_TIME_MS))

    if (( elapsed < DEBOUNCE_TIME_MS )); then
        return 0  # Should debounce
    fi

    LAST_EVENT_TIME_MS=$current_time_ms
    return 1  # Don't debounce
}

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

function load_state() {
    if [[ -f "$STATE_FILE" ]]; then
        cat "$STATE_FILE"
    else
        echo "|||||"
    fi
}

function save_state() {
    echo "$1" > "$STATE_FILE"
}

function get_track_key() {
    echo "${1}::${2}"
}

function should_notify() {
    local old_state="$1"
    local new_state="$2"

    local old_status old_title old_artist
    local new_type new_status new_title new_artist

    IFS='|' read -r _ _ old_status old_title old_artist _ <<< "$old_state"
    IFS='|' read -r new_type _ new_status new_title new_artist _ <<< "$new_state"

    # ONLY notify when something is Playing
    [[ "$new_status" != "Playing" ]] && return 1

    local track_key
    track_key=$(get_track_key "$new_title" "$new_artist")

    local current_time_sec
    current_time_sec=$(date +%s)

    # Check history window (10 seconds)
    if [[ -n "${NOTIFIED_TRACKS[$track_key]:-}" ]]; then
        local last_notif_time="${NOTIFIED_TRACKS[$track_key]}"
        local time_diff=$((current_time_sec - last_notif_time))

        if [[ $time_diff -lt 10 ]]; then
            return 1
        fi
    fi

    # Update notification timestamp
    NOTIFIED_TRACKS[$track_key]=$current_time_sec
    return 0
}

# ============================================================================
# NOTIFICATION FORMATTING
# ============================================================================

function send_notification() {
    local old_state="$1"
    local new_state="$2"
    local art_url="$3"

    local new_type new_status new_title new_artist new_album
    IFS='|' read -r new_type _ new_status new_title new_artist new_album <<< "$new_state"

    local source_icon
    case "$new_type" in
        browser) source_icon="ðŸŒ" ;;
        song)    source_icon="ðŸŽµ" ;;
        *)       source_icon="" ;;
    esac

    local notif_title="$source_icon Now Playing"
    local notif_body="$new_title"

    [[ -n "$new_artist" && "$new_artist" != "Unknown" ]] && \
        notif_body="$notif_body"$'\n'"by $new_artist"

    [[ -n "$new_album" && "$new_album" != "Unknown" ]] && \
        notif_body="$notif_body"$'\n'"from $new_album"

    local notify_cmd=(
        notify-send
        -t "$NOTIFICATION_TIMEOUT"
        -a "$NOTIFICATION_APP"
        -u normal
        -h string:x-canonical-private-synchronous:medianotify
    )

    if [[ -n "$art_url" ]]; then
        local art_path="${art_url#file://}"
        [[ -f "$art_path" ]] && notify_cmd+=(-i "$art_path")
    fi

    notify_cmd+=("$notif_title" "$notif_body")

    "${notify_cmd[@]}" 2>/dev/null || log "Failed to send notification"
    log "Notification sent: $new_title"
}

# ============================================================================
# EVENT HANDLING
# ============================================================================

function handle_event() {
    # Note: This function now runs in the MAIN process scope

    if should_debounce; then
        return
    fi

    # Get current state from mediactl
    local current_state
    current_state=$(mediactl status 2>/dev/null || echo "idle||Idle|||")

    local type player status title artist album art_url
    IFS='|' read -r type player status title artist album art_url <<< "$current_state"

    if [[ -z "$type" ]]; then
        return
    fi

    local state_key="$type|$player|$status|$title|$artist|$album"
    local last_state
    last_state=$(load_state)

    if should_notify "$last_state" "$state_key"; then
        send_notification "$last_state" "$state_key" "$art_url"
    fi

    save_state "$state_key"
}

# ============================================================================
# MONITORING LOGIC
# ============================================================================

function kill_writers() {
    # Only kill the background 'playerctl' processes feeding the pipe
    for pid in "${MONITOR_PIDS[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
    done
    MONITOR_PIDS=()
}

function spawn_writers() {
    kill_writers
    local current_players="$1"

    if [[ -n "$current_players" ]]; then
        log "Monitoring: $(echo "$current_players" | tr '\n' ' ')"

        # We redirect output to the Named Pipe
        # We assume the Main Loop is already reading from it
        playerctl -a -F metadata > "$EVENT_PIPE" 2>/dev/null &
        MONITOR_PIDS+=($!)

        playerctl -a -F status > "$EVENT_PIPE" 2>/dev/null &
        MONITOR_PIDS+=($!)
    fi
}

function main_loop() {
    log "Starting daemon..."

    # Ensure FIFO exists
    init_state_dir

    # 1. Open the FIFO for Read+Write (FD 3).
    # This prevents the 'read' loop from receiving EOF when writer processes die/restart.
    exec 3<> "$EVENT_PIPE"

    # 2. Start the background check for player list changes
    (
        local known_players=""
        while true; do
            local current_players
            current_players=$(playerctl -l 2>/dev/null || echo "")

            if [[ "$current_players" != "$known_players" ]]; then
                # Write a special internal signal to the pipe to trigger update
                echo "INTERNAL_UPDATE_PLAYERS $current_players" > "$EVENT_PIPE"
                known_players="$current_players"
            fi
            sleep 2
        done
    ) &
    local CHECKER_PID=$!

    # 3. Main Blocking Loop: Reads from FIFO
    # Because we read from FD 3 or the file, and we keep it open, this loop never dies.
    while read -r line <&3; do
        if [[ "$line" == "INTERNAL_UPDATE_PLAYERS "* ]]; then
            # Player list changed
            local new_list="${line#INTERNAL_UPDATE_PLAYERS }"
            spawn_writers "$new_list"
            # Trigger an immediate check
            handle_event
        else
            # Standard playerctl output or empty line
            handle_event
        fi
    done

    # If we get here, something broke the pipe mechanism
    kill "$CHECKER_PID" 2>/dev/null
}

# ============================================================================
# SIGNAL HANDLING
# ============================================================================

function cleanup() {
    log "Shutting down..."
    kill_writers
    pkill -P $$ 2>/dev/null || true
    rm -f "$EVENT_PIPE" "$STATE_DIR/events" 2>/dev/null
    exec 3>&- # Close FD
    exit 0
}

trap cleanup SIGINT SIGTERM EXIT

# ============================================================================
# ENTRY POINT
# ============================================================================

check_dependencies
main_loop
