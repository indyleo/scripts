#!/usr/bin/env bash
# medianotify - Event-driven media player notification daemon
# Monitors media state changes via playerctl events and queries mediactl

set -euo pipefail

# ============================================================================
# CONFIGURATION
# ============================================================================

readonly SCRIPT_NAME="medianotify"
readonly STATE_DIR="${XDG_RUNTIME_DIR:-/tmp}/medianotify"
readonly STATE_FILE="$STATE_DIR/last_state"
readonly NOTIFICATION_TIMEOUT=5000
readonly NOTIFICATION_APP="Media Player"

# Debounce settings (prevent notification spam from rapid events)
readonly DEBOUNCE_TIME=0.3  # seconds
declare -g LAST_EVENT_TIME=0

# Track notification history to prevent duplicates
declare -gA NOTIFIED_TRACKS=()

# Job tracking for proper cleanup
declare -ga MONITOR_PIDS=()

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

function log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" >&2
}

function die() {
    log "ERROR: $*"
    exit 1
}

function check_dependencies() {
    command -v mediactl &>/dev/null || die "mediactl not found in PATH"
    command -v playerctl &>/dev/null || die "playerctl not found in PATH"
    command -v notify-send &>/dev/null || die "notify-send not found"
    command -v bc &>/dev/null || die "bc not found (required for debouncing)"
}

function init_state_dir() {
    mkdir -p "$STATE_DIR"
}

function get_current_time() {
    date +%s.%N
}

function should_debounce() {
    local current_time
    current_time=$(get_current_time)

    local elapsed
    elapsed=$(echo "$current_time - $LAST_EVENT_TIME" | bc)

    if (( $(echo "$elapsed < $DEBOUNCE_TIME" | bc -l) )); then
        return 0  # Should debounce
    fi

    LAST_EVENT_TIME=$current_time
    return 1  # Don't debounce
}

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

function load_state() {
    if [[ -f "$STATE_FILE" ]]; then
        cat "$STATE_FILE"
    else
        echo "|||||"
    fi
}

function save_state() {
    local state="$1"
    echo "$state" > "$STATE_FILE"
}

function get_track_key() {
    local title="$1"
    local artist="$2"
    echo "${title}::${artist}"
}

function should_notify() {
    local old_state="$1"
    local new_state="$2"

    local old_status old_title old_artist
    local new_type new_status new_title new_artist

    IFS='|' read -r _ _ old_status old_title old_artist _ <<< "$old_state"
    IFS='|' read -r new_type _ new_status new_title new_artist _ <<< "$new_state"

    # ONLY notify when something is Playing
    [[ "$new_status" != "Playing" ]] && return 1

    local track_key
    track_key=$(get_track_key "$new_title" "$new_artist")

    # Check if we've already notified about this track being played
    local current_time
    current_time=$(date +%s)

    # If we notified about this track in the last 10 seconds, skip
    if [[ -n "${NOTIFIED_TRACKS[$track_key]:-}" ]]; then
        local last_notif_time="${NOTIFIED_TRACKS[$track_key]}"
        local time_diff=$((current_time - last_notif_time))

        if [[ $time_diff -lt 10 ]]; then
            return 1
        fi
    fi

    # Update notification timestamp for this track
    NOTIFIED_TRACKS[$track_key]=$current_time

    return 0
}

# ============================================================================
# NOTIFICATION FORMATTING
# ============================================================================

function get_notification_title() {
    local new_type="$1"

    local source_icon
    case "$new_type" in
        browser) source_icon="ðŸŒ" ;;
        song)    source_icon="ðŸŽµ" ;;
        *)       source_icon="" ;;
    esac

    echo "$source_icon Now Playing"
}

function get_notification_body() {
    local title="$1"
    local artist="$2"
    local album="$3"

    local body="$title"

    [[ -n "$artist" && "$artist" != "Unknown" ]] && \
        body="$body"$'\n'"by $artist"

    [[ -n "$album" && "$album" != "Unknown" ]] && \
        body="$body"$'\n'"from $album"

    echo "$body"
}

function send_notification() {
    local old_state="$1"
    local new_state="$2"
    local art_url="$3"

    local new_type new_status new_title new_artist new_album
    IFS='|' read -r new_type _ new_status new_title new_artist new_album <<< "$new_state"

    local notif_title notif_body
    notif_title=$(get_notification_title "$new_type")
    notif_body=$(get_notification_body "$new_title" "$new_artist" "$new_album")

    local notify_cmd=(
        notify-send
        -t "$NOTIFICATION_TIMEOUT"
        -a "$NOTIFICATION_APP"
        -u normal
    )

    # Add album art if available
    if [[ -n "$art_url" ]]; then
        local art_path="${art_url#file://}"
        [[ -f "$art_path" ]] && notify_cmd+=(-i "$art_path")
    fi

    notify_cmd+=("$notif_title" "$notif_body")

    "${notify_cmd[@]}" 2>/dev/null || {
        log "Failed to send notification"
        return 1
    }

    log "Notification sent: $notif_title - $new_title"
}

# ============================================================================
# EVENT HANDLING
# ============================================================================

function handle_event() {
    # Debounce rapid successive events
    if should_debounce; then
        return
    fi

    # Get current state from mediactl (uses its intelligent prioritization)
    local current_state
    current_state=$(mediactl status 2>/dev/null || echo "idle||Idle|||")

    # Extract relevant fields
    local type player status title artist album art_url
    IFS='|' read -r type player status title artist album art_url <<< "$current_state"

    # Validate we got the expected number of fields
    if [[ -z "$type" ]]; then
        log "Warning: Invalid state format from mediactl"
        return
    fi

    # Create state key for comparison (without art_url to match saved format)
    local state_key="$type|$player|$status|$title|$artist|$album"

    local last_state
    last_state=$(load_state)

    # Check if notification is needed
    if should_notify "$last_state" "$state_key"; then
        send_notification "$last_state" "$state_key" "$art_url"
    fi

    # Update state
    save_state "$state_key"
}

# ============================================================================
# EVENT MONITORING
# ============================================================================

function kill_monitors() {
    log "Stopping existing monitors..."

    # Kill tracked background jobs
    for pid in "${MONITOR_PIDS[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
    done

    # Also kill any playerctl processes we started
    pkill -P $$ playerctl 2>/dev/null || true

    # Clear the array
    MONITOR_PIDS=()

    # Give processes time to die
    sleep 0.2
}

function monitor_events() {
    log "Starting event-driven media monitoring"

    # Handle initial state
    LAST_EVENT_TIME=0
    handle_event

    # Keep track of known players
    local known_players=""

    # Main monitoring loop
    while true; do
        # Get current list of players
        local current_players
        current_players=$(playerctl -l 2>/dev/null || echo "")

        # If players changed, restart monitoring
        if [[ "$current_players" != "$known_players" ]]; then
            log "Player list changed, updating monitor..."
            known_players="$current_players"

            # Kill existing monitors
            kill_monitors

            # If we have players, start monitoring them
            if [[ -n "$current_players" ]]; then
                log "Monitoring players: $(echo "$current_players" | tr '\n' ' ')"

                # Start monitoring in background and track PIDs
                playerctl -a -F metadata 2>/dev/null | while read -r line; do
                    handle_event
                done &
                MONITOR_PIDS+=($!)

                playerctl -a -F status 2>/dev/null | while read -r line; do
                    handle_event
                done &
                MONITOR_PIDS+=($!)

                log "Started ${#MONITOR_PIDS[@]} monitor processes"
            else
                log "No players available, waiting..."
            fi
        fi

        # Check for player changes every 2 seconds
        sleep 2
    done
}

# ============================================================================
# SIGNAL HANDLING
# ============================================================================

function cleanup() {
    log "Shutting down gracefully"

    # Kill background playerctl processes
    kill_monitors

    # Clean up FIFO if it exists
    rm -f "$STATE_DIR/events" 2>/dev/null || true

    exit 0
}

trap cleanup SIGINT SIGTERM EXIT

# ============================================================================
# HELP & VERSION
# ============================================================================

function show_help() {
    cat << EOF
$SCRIPT_NAME - Event-driven media player notification daemon

USAGE:
    $SCRIPT_NAME [options]

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version

DESCRIPTION:
    Monitors media player state via playerctl EVENTS (no polling!)
    and queries mediactl for intelligent source prioritization.
    Sends desktop notifications when tracks change or playback starts.

FEATURES:
    - Event-driven (instant response, zero polling delay)
    - No CPU usage when idle (only wakes on actual media events)
    - Deduplicates notifications (no spam)
    - Uses mediactl's intelligent browser/song prioritization
    - Shows source indicator (browser ðŸŒ vs song ðŸŽµ)
    - Album art support
    - Smart debouncing for rapid events
    - Persistent state across restarts
    - Track-based notification history (10s window)

NOTIFICATION TRIGGERS:
    âœ“ Track starts playing (new track)
    âœ“ Resume from paused/stopped to playing (new track only)
    âœ“ Source changes while playing (browser â†” song)
    âœ— No notification when pausing
    âœ— No notification when stopping
    âœ— No notification when idle
    âœ— No duplicate notifications for same track within 10s

HOW IT WORKS:
    1. Listens to playerctl events from ALL players (--all-players)
    2. On any event, queries mediactl for current prioritized state
    3. Debounces rapid successive events (${DEBOUNCE_TIME}s window)
    4. Tracks notification history to prevent duplicates
    5. Sends notification only when appropriate

RUNNING AS A SERVICE:
    systemd user service:
        1. Create ~/.config/systemd/user/medianotify.service:

           [Unit]
           Description=Media notification daemon
           After=graphical-session.target

           [Service]
           Type=simple
           ExecStart=/path/to/medianotify
           Restart=on-failure

           [Install]
           WantedBy=default.target

        2. systemctl --user enable --now medianotify.service

REQUIREMENTS:
    - mediactl (your custom media controller)
    - playerctl (for event monitoring)
    - notify-send (for notifications)
    - bc (for floating-point debounce calculations)

EOF
}

function show_version() {
    echo "$SCRIPT_NAME v2.0.1 (event-driven, fixed)"
}

# ============================================================================
# MAIN
# ============================================================================

function main() {
    case "${1:-}" in
        -h|--help)    show_help; exit 0 ;;
        -v|--version) show_version; exit 0 ;;
        "")           ;;
        *)            die "Unknown option: $1 (try --help)" ;;
    esac

    check_dependencies
    init_state_dir
    monitor_events
}

main "$@"
